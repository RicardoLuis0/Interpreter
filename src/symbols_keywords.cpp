#include "symbols_keywords.h"
#include <stdexcept>

Lexer::symbol_data get_symbol_data(symbol_type_t s){
    for(auto sd:base_symbols){
        if(sd.type==s)return sd;
    }
    //unreachable
    throw std::runtime_error("unreachable");
}

std::vector<Lexer::keyword_data> base_keywords{
    {"if","KEYWORD_IF",KEYWORD_IF},
    {"else","KEYWORD_ELSE",KEYWORD_ELSE},
    {"switch","KEYWORD_SWITCH",KEYWORD_SWITCH},
    {"case","KEYWORD_CASE",KEYWORD_CASE},
    {"for","KEYWORD_FOR",KEYWORD_FOR},
    {"do","KEYWORD_DO",KEYWORD_DO},
    {"while","KEYWORD_WHILE",KEYWORD_WHILE},
    {"break","KEYWORD_BREAK",KEYWORD_BREAK},
    {"continue","KEYWORD_CONTINUE",KEYWORD_CONTINUE},
    {"return","KEYWORD_RETURN",KEYWORD_RETURN},
    {"signed","KEYWORD_SIGNED",KEYWORD_SIGNED},
    {"unsigned","KEYWORD_UNSIGNED",KEYWORD_UNSIGNED},
    {"true","KEYWORD_TRUE",KEYWORD_TRUE},
    {"false","KEYWORD_FALSE",KEYWORD_FALSE},
    /*
    {"null","KEYWORD_NULL",KEYWORD_NULL},
    {"static","KEYWORD_STATIC",KEYWORD_STATIC},
    */
    {"void","KEYWORD_VOID",KEYWORD_VOID},
    {"char","KEYWORD_CHAR",KEYWORD_CHAR},
    {"int","KEYWORD_INT",KEYWORD_INT},
    {"float","KEYWORD_FLOAT",KEYWORD_FLOAT},
    {"string","KEYWORD_STRING",KEYWORD_STRING},
    /*
    {"class","KEYWORD_CLASS",KEYWORD_CLASS},
    {"public","KEYWORD_PUBLIC",KEYWORD_PUBLIC},
    {"protected","KEYWORD_PROTECTED",KEYWORD_PROTECTED},
    {"private","KEYWORD_PRIVATE",KEYWORD_PRIVATE},
    */
};

std::vector<Lexer::symbol_data> base_symbols{
    {"#","SYMBOL_HASHTAG",SYMBOL_HASHTAG},
    {";","SYMBOL_SEMICOLON",SYMBOL_SEMICOLON},
    {":","SYMBOL_COLON",SYMBOL_COLON},
    {"?","SYMBOL_QUESTION_MARK",SYMBOL_QUESTION_MARK},
    {",","SYMBOL_COMMA",SYMBOL_COMMA},
    {"(","SYMBOL_PARENTHESIS_OPEN",SYMBOL_PARENTHESIS_OPEN},
    {")","SYMBOL_PARENTHESIS_CLOSE",SYMBOL_PARENTHESIS_CLOSE},
    {"[","SYMBOL_SQUARE_BRACKET_OPEN",SYMBOL_SQUARE_BRACKET_OPEN},
    {"]","SYMBOL_SQUARE_BRACKET_CLOSE",SYMBOL_SQUARE_BRACKET_CLOSE},
    {"{","SYMBOL_CURLY_BRACKET_OPEN",SYMBOL_CURLY_BRACKET_OPEN},
    {"}","SYMBOL_CURLY_BRACKET_CLOSE",SYMBOL_CURLY_BRACKET_CLOSE},
    {"+","SYMBOL_PLUS",SYMBOL_PLUS},
    {"-","SYMBOL_MINUS",SYMBOL_MINUS},
    {"*","SYMBOL_MULTIPLY",SYMBOL_MULTIPLY},
    {"/","SYMBOL_DIVIDE",SYMBOL_DIVIDE},
    {"%","SYMBOL_PERCENT",SYMBOL_PERCENT},
    {"++","SYMBOL_INCREMENT",SYMBOL_INCREMENT},
    {"--","SYMBOL_DECREMENT",SYMBOL_DECREMENT},
    {"==","SYMBOL_EQUALS",SYMBOL_EQUALS},
    {"!=","SYMBOL_NOT_EQUALS",SYMBOL_NOT_EQUALS},
    {">","SYMBOL_GREATER",SYMBOL_GREATER},
    {">=","SYMBOL_GREATER_EQUALS",SYMBOL_GREATER_EQUALS},
    {"<","SYMBOL_LOWER",SYMBOL_LOWER},
    {"<=","SYMBOL_LOWER_EQUALS",SYMBOL_LOWER_EQUALS},
    {"&&","SYMBOL_LOGICAL_AND",SYMBOL_LOGICAL_AND},
    {"||","SYMBOL_LOGICAL_OR",SYMBOL_LOGICAL_OR},
    {"!","SYMBOL_LOGICAL_NOT",SYMBOL_LOGICAL_NOT},
    {"&","SYMBOL_BITWISE_AND",SYMBOL_BITWISE_AND},
    {"|","SYMBOL_BITWISE_OR",SYMBOL_BITWISE_OR},
    {"^","SYMBOL_BITWISE_XOR",SYMBOL_BITWISE_XOR},
    {"~","SYMBOL_BITWISE_NOT",SYMBOL_BITWISE_NOT},
    {"<<","SYMBOL_LEFT_SHIFT",SYMBOL_LEFT_SHIFT},
    {">>","SYMBOL_RIGHT_SHIFT",SYMBOL_RIGHT_SHIFT},
    {"=","SYMBOL_ASSIGNMENT",SYMBOL_ASSIGNMENT},
    {"+=","SYMBOL_PLUS_ASSIGNMENT",SYMBOL_PLUS_ASSIGNMENT},
    {"-=","SYMBOL_MINUS_ASSIGNMENT",SYMBOL_MINUS_ASSIGNMENT},
    {"*=","SYMBOL_MULTIPLY_ASSIGNMENT",SYMBOL_MULTIPLY_ASSIGNMENT},
    {"/=","SYMBOL_DIVIDE_ASSIGNMENT",SYMBOL_DIVIDE_ASSIGNMENT},
    {"%=","SYMBOL_PERCENT_ASSIGNMENT",SYMBOL_PERCENT_ASSIGNMENT},
    {"<<=","SYMBOL_LEFT_SHIFT_ASSIGNMENT",SYMBOL_LEFT_SHIFT_ASSIGNMENT},
    {">>=","SYMBOL_RIGHT_SHIFT_ASSIGNMENT",SYMBOL_RIGHT_SHIFT_ASSIGNMENT},
    {"&=","SYMBOL_BITWISE_AND_ASSIGNMENT",SYMBOL_BITWISE_AND_ASSIGNMENT},
    {"|=","SYMBOL_BITWISE_OR_ASSIGNMENT",SYMBOL_BITWISE_OR_ASSIGNMENT},
    {"^=","SYMBOL_BITWISE_XOR_ASSIGNMENT",SYMBOL_BITWISE_XOR_ASSIGNMENT},
    {".","SYMBOL_DOT",SYMBOL_DOT},
    {"->","SYMBOL_ARROW",SYMBOL_ARROW},
};
